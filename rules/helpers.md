# Helpers — 标准化操作参考中心

> 本文件是 Everything Claude Code 的指令解耦核心。
> 所有智能体、技能、命令和规则通过锚点引用本文件中的标准化操作，
> 而非各自重复定义相同内容。

---

## 领域一：标准工作流模板

### 规划工作流模板

```
1. 需求分析 → 理解功能请求，确定验收标准
2. 架构评审 → 分析现有代码库，确定受影响组件
3. 步骤拆解 → 创建详细步骤（文件路径、依赖关系、风险）
4. 实施顺序 → 按依赖关系排优先级，支持增量测试
```

### 代码审查工作流模板

```
1. 运行 git diff 查看最近更改
2. 按优先级审查：
   - 严重 (CRITICAL)：安全漏洞、硬编码凭据 → 必须修复
   - 高 (HIGH)：代码质量问题（大函数、缺失错误处理） → 应该修复
   - 中 (MEDIUM)：性能、最佳实践 → 考虑改进
3. 给出合并决策：
   - ✅ 立即合并：无 CRITICAL/HIGH 问题
   - ⚠️ 修改后合并：存在 HIGH 但可快速修复
   - ❌ 需要重构：存在 CRITICAL 安全问题或架构缺陷
4. 指出代码中做得好的地方（正面反馈）
```

### 构建错误修复工作流模板

```
1. 收集所有错误
   - 运行完整类型检查：npx tsc --noEmit --pretty
   - 按类型分类：类型推断、缺失定义、导入/导出、配置、依赖
   - 按影响排序：阻塞构建 > 类型错误 > 警告

2. 逐个修复（最小差异策略）
   - 理解错误信息，检查文件和行号
   - 寻找最小修复方案（添加类型注解、修复导入、添加空值检查）
   - 每次修复后重新编译验证
   - 跟踪进度：已修复 X/Y 个错误

3. 禁止事项
   - ❌ 重构不相关代码
   - ❌ 更改架构
   - ❌ 添加新功能
   - ❌ 优化性能或改善代码风格
```

---

## 领域二：报告格式模板

### 验证报告模板

```
VERIFICATION REPORT
==================

Build:     [PASS/FAIL]
Types:     [PASS/FAIL] (X errors)
Lint:      [PASS/FAIL] (X warnings)
Tests:     [PASS/FAIL] (X/Y passed, Z% coverage)
Security:  [PASS/FAIL] (X issues)
Diff:      [X files changed]

Overall:   [READY/NOT READY] for PR

Issues to Fix:
1. ...
2. ...
```

### 构建错误修复报告模板

```markdown
# 构建错误修复报告

**构建目标：** Next.js 生产环境 / TypeScript 检查 / ESLint
**初始错误数：** X
**已修复错误数：** Y
**构建状态：** ✅ 通过 / ❌ 失败

## 已修复的错误

### 1. [错误类别]
**位置：** `src/path/file.ts:行号`
**错误信息：** [原始错误]
**根本原因：** [原因说明]
**修复：** 修改行数 N，影响：无/[说明]

## 验证步骤
1. ✅ TypeScript 检查通过
2. ✅ 构建成功
3. ✅ 未引入新错误
```

### 安全审查报告模板

```markdown
# 安全审查报告

**文件/组件：** [path/to/file.ts]
**审查人：** security-reviewer 智能体

## 摘要
- **致命 (Critical):** X
- **高危 (High):** Y
- **中危 (Medium):** Z
- **风险等级：** 🔴 高 / 🟡 中 / 🟢 低

## [严重程度] 问题
**类别：** [SQL 注入 / XSS / 身份验证 / 等]
**位置：** `file.ts:行号`
**问题描述：** [漏洞说明]
**影响：** [被利用后果]
**修复建议：** [安全实现方案]
**参考：** OWASP / CWE 编号
```

### 诊断报告模板

```markdown
# 错误诊断报告

## 问题概览
- **问题描述**：[现象]
- **发生时间**：[时间和频率]
- **影响范围**：[用户和功能]
- **紧急程度**：[P0/P1/P2/P3]

## 根因分析
### 时间线
[时间点1] → [时间点2] → [问题爆发]

### 原因链
1. **直接原因**：[直接因素]
2. **间接原因**：[深层因素]
3. **根本原因**：[最深层原因]

## 解决方案
- **临时措施**：[快速恢复方案]
- **根因修复**：[彻底修复方案]
- **预防措施**：[监控 + 流程 + 测试]
```

### 代码审查输出格式

```
[CRITICAL/HIGH/MEDIUM] 问题标题
文件: src/path/file.ts:行号
问题: 问题描述
修复: 修复建议

代码示例（错误 vs 正确）
```

---

## 领域三：检查清单模板

### 安全检查清单

提交代码前必须确认：

- [ ] 无硬编码凭据（API 密钥、密码、令牌）
- [ ] 所有用户输入已验证和净化
- [ ] SQL 查询使用参数化方式（预防注入）
- [ ] HTML 输出已转义（预防 XSS）
- [ ] 已启用 CSRF 保护
- [ ] 身份验证/授权已验证
- [ ] 所有端点已设置速率限制
- [ ] 错误消息不泄露敏感数据
- [ ] 敏感数据已加密或脱敏
- [ ] 依赖项已更新，无已知漏洞

### 代码质量自检清单

- [ ] 代码易读且命名良好
- [ ] 函数体量小（<50 行）
- [ ] 文件内容聚焦（<800 行）
- [ ] 无深度嵌套（>4 层）
- [ ] 具备完善的错误处理
- [ ] 不存在 console.log 语句
- [ ] 不存在硬编码数值
- [ ] 不存在修改原对象操作（已采用不可变模式）

### 测试质量检查清单

- [ ] 所有公共函数都有单元测试
- [ ] 所有 API 接口都有集成测试
- [ ] 关键用户流程有 E2E 测试
- [ ] 覆盖了边界情况（null、空值、无效输入）
- [ ] 测试了错误路径（不只是正常流程）
- [ ] 对外部依赖使用了 Mock
- [ ] 测试是独立的（无共享状态）
- [ ] 测试名称描述了被测内容
- [ ] 断言明确且有意义
- [ ] 覆盖率达到 80%+

### 结构化代码审查清单

**安全维度：**
- [ ] 无硬编码凭据
- [ ] 所有用户输入已验证和净化
- [ ] SQL 查询使用参数化方式
- [ ] 敏感数据已加密或脱敏
- [ ] 权限检查覆盖所有端点
- [ ] 错误信息不泄露内部实现细节

**性能维度：**
- [ ] 无 N+1 查询问题
- [ ] 热点数据有缓存策略
- [ ] 大数据集有分页处理
- [ ] 异步操作正确使用 async/await
- [ ] 资源（连接、文件句柄）及时释放
- [ ] 无不必要的重复计算或渲染

**代码质量维度：**
- [ ] 函数职责单一，体量小（<50 行）
- [ ] 文件内容聚焦（<800 行）
- [ ] 命名清晰一致，无歧义
- [ ] 错误处理完善，无静默失败
- [ ] 无重复代码（DRY 原则）
- [ ] 使用不可变模式，无直接修改原对象

---

## 领域四：错误处理协议

### 三次错误协议

当同一个错误反复出现时，遵循递进式修复策略：

```
尝试 1：诊断并修复
  → 仔细阅读错误信息
  → 识别根本原因
  → 应用针对性修复
  → 记录到 task_plan.md 错误表（如果 file-memory 激活）

尝试 2：替代方案
  → 同样错误？尝试不同方法
  → 不同工具？不同库？不同配置？
  → 永远不要重复完全相同的失败操作
  → 更新错误表的尝试次数

尝试 3：更广泛的重新思考
  → 质疑假设——错误的根因可能不是你想的那样
  → 搜索解决方案（Stack Overflow、GitHub Issues）
  → 考虑是否需要更新整体方案

3 次失败后：升级给用户
  → 解释尝试了什么（3 种不同方法）
  → 分享具体错误信息
  → 请求指导或额外上下文
```

### 安全应急响应协议

发现致命安全漏洞时：

```
1. 立即停止当前工作
2. 记录 — 创建详细报告
3. 通知 — 立即向项目所有者发出警报
4. 建议修复 — 提供安全的代码示例
5. 测试修复 — 验证修复方案有效
6. 核实影响 — 检查漏洞是否已被利用
7. 轮换密钥 — 若凭据已泄露
```

### 问题优先级分类

```
P0-紧急：系统不可用、数据丢失、安全漏洞 → 立即响应
P1-高：  核心功能异常、性能严重下降 → 尽快处理
P2-中：  部分功能异常、用户体验受影响 → 排期修复
P3-低：  偶发问题、轻微体验影响 → 有空处理
```

---

## 领域五：File-Memory 集成

### 三文件模式

| 文件 | 用途 | 更新时机 |
|------|------|----------|
| `task_plan.md` | 阶段跟踪、进度、决策、错误表 | 每个阶段完成后 |
| `findings.md` | 研究发现、技术决策、知识存储 | 任何发现后立即更新 |
| `progress.md` | 会话日志、测试结果、5 问题重启检查 | 整个会话过程中 |

文件位置：`.claude/plans/` 目录下。

### 六条核心规则

1. **先创建计划** — 永远不要在没有 `task_plan.md` 的情况下开始复杂任务
2. **2 操作规则** — 每进行 2 次查看/浏览/搜索操作后，立即将关键发现保存到 `findings.md`
3. **决策前读取** — 在做出重大决策前，读取 `task_plan.md`（利用注意力操纵原理）
4. **行动后更新** — 完成阶段后更新状态、记录错误、记录文件变更
5. **记录所有错误** — 每个错误都记录在错误表中：`| 错误描述 | 尝试次数 | 解决方案 |`
6. **三次错误协议** — 参见 [三次错误协议](#三次错误协议)

### 读写决策矩阵

| 情况 | 操作 | 原因 |
|------|------|------|
| 刚写入文件 | 不读取 | 内容仍在上下文中 |
| 查看图片/PDF | 立即写入发现 | 多模态→文本，防止丢失 |
| 浏览器返回数据 | 写入文件 | 截图不持久 |
| 开始新阶段 | 读取计划/发现 | 上下文可能过时 |
| 发生错误 | 读取相关文件 | 需要当前状态来修复 |
| 间隔后恢复 | 读取所有规划文件 | 恢复状态 |

### 五问题重启测试

会话恢复时，如果能回答这 5 个问题，说明上下文管理良好：

| 问题 | 答案来源 |
|------|----------|
| 我在哪里？ | `task_plan.md` 中的当前阶段 |
| 我要去哪里？ | 剩余阶段 |
| 目标是什么？ | 计划中的目标陈述 |
| 我学到了什么？ | `findings.md` |
| 我做了什么？ | `progress.md` |

### Planner 智能体协调

当 `.claude/plans/task_plan.md` 存在时：
1. 将实施方案的阶段列表写入 `task_plan.md` 的"阶段列表"部分
2. 将关键技术决策写入 `task_plan.md` 的"决策记录"表
3. 将识别的风险记录到 `findings.md`

---

## 领域六：通用验证六阶段

### 阶段 1：构建验证

```bash
npm run build 2>&1 | tail -20
# 或 pnpm build 2>&1 | tail -20
```

如果构建失败，停止并修复后再继续。

### 阶段 2：类型检查

```bash
# TypeScript
npx tsc --noEmit 2>&1 | head -30
# Python
pyright . 2>&1 | head -30
```

### 阶段 3：Lint 检查

```bash
# JavaScript/TypeScript
npm run lint 2>&1 | head -30
# Python
ruff check . 2>&1 | head -30
```

### 阶段 4：测试套件

```bash
npm run test -- --coverage 2>&1 | tail -50
# 目标：最低 80% 覆盖率
```

### 阶段 5：安全扫描

```bash
# 检查密钥
grep -rn "sk-" --include="*.ts" --include="*.js" . 2>/dev/null | head -10
grep -rn "api_key" --include="*.ts" --include="*.js" . 2>/dev/null | head -10
# 检查 console.log
grep -rn "console.log" --include="*.ts" --include="*.tsx" src/ 2>/dev/null | head -10
```

### 阶段 6：差异审查

```bash
git diff --stat
git diff HEAD~1 --name-only
```

审查每个变更文件，确认无意间变更、缺失错误处理、潜在边缘情况。

---

## 领域七：TDD 工作流

### 通用TDD红绿重构循环

```
步骤 1：先写测试（红 / RED）
  → 始终从一个失败的测试开始
  → 覆盖正常流程、边界情况、错误场景

步骤 2：运行测试（验证失败 / FAILS）
  → 测试应当失败——因为功能尚未实现

步骤 3：编写最简实现（绿 / GREEN）
  → 只编写刚好能通过测试的代码

步骤 4：运行测试（验证通过 / PASSES）
  → 所有测试应当通过

步骤 5：重构（改进 / IMPROVE）
  → 消除重复、优化命名、提升性能、增强可读性

步骤 6：验证覆盖率
  → 运行 test:coverage，验证 80%+
  → 核心代码（财务计算、认证逻辑、安全代码）要求 100%
```

### 测试金字塔比例

- **70% 单元测试**：快速、独立、大量覆盖函数和方法
- **20% 集成测试**：验证组件间协作、API 接口、数据库操作
- **10% E2E 测试**：覆盖核心用户场景和关键业务流程

### 测试用例设计方法

- **简单输入验证** → 等价类划分法
- **多条件组合逻辑** → 因果图法
- **用户流程测试** → 场景分析法
- **有状态系统** → 状态迁移法
- **复杂功能** → 组合使用多种方法

### 必须测试的边界情况

1. **Null/Undefined**：输入为 null 怎么办？
2. **空值**：数组/字符串为空怎么办？
3. **无效类型**：传入错误类型怎么办？
4. **边界值**：最小/最大值
5. **错误**：网络失败、数据库错误
6. **竞态条件**：并发操作
7. **大数据**：10k+ 条数据时的性能
8. **特殊字符**：Unicode、表情符号、SQL 字符

### TDD 最佳实践

**建议做法：**
- ✅ 先编写测试，在进行任何实现之前
- ✅ 运行测试并验证它们失败后再写实现
- ✅ 编写最小化代码以使测试通过
- ✅ 仅在测试通过后才进行重构
- ✅ 涵盖边界情况和错误场景
- ✅ 目标 80%+ 覆盖率（核心代码 100%）

**避免做法：**
- ❌ 在测试之前编写实现
- ❌ 每次更改后跳过运行测试
- ❌ 一次性编写过多代码
- ❌ 忽略失败的测试
- ❌ 测试实现细节（应测试行为）
- ❌ Mock 一切（更推荐集成测试）

---

## 领域八：安全审查流程

### OWASP Top 10 检查

```
1. 注入 (SQL, NoSQL, Command)
   → 查询是否参数化？用户输入是否经过清洗？

2. 失效的身份验证
   → 密码是否哈希处理？JWT 是否正确验证？会话是否安全？

3. 敏感数据泄露
   → 是否强制 HTTPS？密钥是否在环境变量中？PII 是否加密？

4. XML 外部实体 (XXE)
   → XML 解析器配置是否安全？

5. 失效的访问控制
   → 每个路由是否检查授权？CORS 配置是否正确？

6. 安全配置错误
   → 默认凭据是否已更改？安全标头是否设置？

7. 跨站脚本 (XSS)
   → 输出是否转义/清洗？是否设置 CSP？

8. 不安全的反序列化
   → 用户输入反序列化是否安全？

9. 使用含已知漏洞的组件
   → 依赖项是否已更新？npm audit 是否清空？

10. 日志记录和监控不足
    → 安全事件是否记录？是否配置告警？
```

### 安全审查触发条件

**必须审查：**
- 添加新 API 端点
- 更改身份验证/授权代码
- 添加用户输入处理逻辑
- 修改数据库查询
- 添加文件上传功能
- 更改支付/金融代码
- 添加外部 API 集成
- 更新依赖项

### 凭据管理规范

```typescript
// 严禁：硬编码凭据
const apiKey = "sk-proj-xxxxx"

// 推荐：环境变量
const apiKey = process.env.OPENAI_API_KEY
if (!apiKey) {
  throw new Error('OPENAI_API_KEY not configured')
}
```

---

## 领域九：并行执行协调

### 并行执行核心原则

**能并行的，绝不串行。** 通过 `Task` 工具的 `run_in_background=true` 实现并行子智能体。

### 四大并行模式

| 模式 | 适用场景 | 智能体数 |
|------|----------|---------|
| 扇形研究 | 多个独立研究领域 | 3-6 |
| 并行章节生成 | 大型文档各章节独立生成 | 3-4 |
| 组件并行设计 | 系统组件独立设计 | 4-6 |
| 故事并行实现 | 冲刺中独立故事并行开发 | 3-5 |

详细模式说明参见 `skills/parallel-patterns/SKILL.md`。

### 子智能体类型选择

| 类型 | 模型 | 适用场景 |
|------|------|----------|
| general-purpose | 继承父级 | 研究、实现、分析 |
| Explore | Haiku | 快速代码库探索（只读） |
| Plan | 继承父级 | 架构规划（只读） |
| Bash | 继承父级 | 隔离的终端命令 |

### 共享上下文协调

```
1. 写入共享上下文到 .claude/plans/parallel-context.md
2. 启动智能体，提示中包含文件路径
3. 每个智能体写入输出到 .claude/plans/parallel-output-{n}.md
4. 主上下文收集并合成所有输出
```

### 并行 vs 顺序决策矩阵

| 场景 | 推荐 | 原因 |
|------|------|------|
| 代码审查 + 安全审查 | 并行 | 完全独立 |
| 规划 → 编码 | 顺序 | 编码依赖规划 |
| 规划 + 架构设计 | 并行 | 可独立进行 |
| 编码 → 测试 | 顺序 | 测试依赖代码 |
| 多维度分析 | 并行 | 各维度独立 |
| 构建修复 → 验证 | 顺序 | 验证依赖修复 |

### 并行执行检查清单

- [ ] 确认任务之间无依赖关系
- [ ] 共享上下文已写入文件
- [ ] 每个智能体有清晰的输出位置
- [ ] 子智能体提示词自包含
- [ ] 已规划结果合成方法
- [ ] 智能体数量不超过 6 个

### 反模式

- ❌ 为琐碎任务（<1K tokens）启动智能体
- ❌ 将整个对话历史传给子智能体
- ❌ 创建深层嵌套的子智能体链
- ❌ 将有依赖关系的任务并行启动
- ❌ 一次启动超过 6 个智能体
