# 并行子智能体模式 (Parallel Subagent Patterns)

> 基于 BMAD 框架的并行执行架构，适配 ECC 智能体体系。
> 核心原则：**能并行的，绝不串行。**

---

## 何时使用

- 多个独立的分析/审查任务（如代码审查 + 安全审查 + 架构审查）
- 复杂功能规划（规划 + 架构 + 安全分析可并行）
- 大型文档生成（各章节逻辑独立）
- 冲刺开发中多个独立故事的并行实现

## 何时不使用

- 任务有严格的顺序依赖（如必须先规划再编码）
- 单个琐碎任务（<1K tokens 的工作量）
- 需要实时交互的场景
- 智能体数量超过 6 个（协调成本过高）

---

## 子智能体类型

通过 `Task` 工具调用，设置 `run_in_background: true` 实现并行：

| 类型 | 模型 | 工具 | 适用场景 |
|------|------|------|----------|
| **general-purpose** | 继承父级 | 所有工具 | 研究、实现、分析 |
| **Explore** | Haiku | Read, Grep, Glob（只读） | 快速代码库探索 |
| **Plan** | 继承父级 | 只读工具 | 架构规划、设计决策 |
| **Bash** | 继承父级 | 仅 Bash | 隔离的终端命令 |

选择建议：
- 快速搜索/探索 → `Explore`（成本低、速度快）
- 需要写文件/执行命令 → `general-purpose`
- 纯规划/分析 → `Plan`
- 仅需终端操作 → `Bash`

---

## 四大并行模式

### 模式 1：扇形研究 (Fan-Out Research)

多个独立研究领域同时进行，最后合成结果。

```
主上下文
    ↓ 启动并行智能体
    ├→ 智能体 1：领域 A 研究
    ├→ 智能体 2：领域 B 研究
    ├→ 智能体 3：领域 C 研究
    └→ 智能体 4：领域 D 研究
    ↓ 收集并合成结果
最终报告
```

**ECC 应用场景：**
- 多维度代码分析（代码质量 + 安全性 + 性能）
- 技术选型调研（多个方案并行评估）
- Bug 根因排查（多个假设并行验证）

**适用条件：**
- 研究领域之间无依赖
- 每个任务工作量实质性（5K+ tokens）
- 需要多角度综合分析

---

### 模式 2：并行章节生成 (Parallel Section Generation)

基于共享上下文，各智能体独立生成文档的不同章节。

```
共享上下文（写入文件）
    ↓ 各智能体读取共享上下文
    ├→ 智能体 1：章节 A
    ├→ 智能体 2：章节 B
    ├→ 智能体 3：章节 C
    └→ 智能体 4：章节 D
    ↓ 组装文档
完整文档
```

**ECC 应用场景：**
- PRD 文档生成（功能需求 + 非功能需求 + 用户故事 + 依赖约束）
- 架构设计文档（各组件设计独立生成）
- 综合审查报告（各维度独立审查后合并）

**适用条件：**
- 章节逻辑独立
- 有明确的共享上下文
- 每个章节工作量实质性（1K+ tokens）

---

### 模式 3：组件并行设计 (Component Parallel Design)

系统有清晰的组件边界时，各组件独立设计后集成。

```
需求定义（PRD/NFR）
    ↓ 每个智能体设计一个组件
    ├→ 智能体 1：认证服务
    ├→ 智能体 2：数据层
    ├→ 智能体 3：API 层
    └→ 智能体 4：UI 层
    ↓ 集成架构
完整系统设计
```

**ECC 应用场景：**
- 微服务架构设计（各服务独立设计）
- 前后端分离项目（前端 + 后端 + 数据库并行设计）
- 测试套件编写（各组件测试独立编写）

**适用条件：**
- 组件有清晰的接口边界
- NFR 已明确
- 组件可独立设计

---

### 模式 4：故事并行实现 (Story Parallel Implementation)

冲刺中多个独立用户故事同时实现。

```
冲刺计划
    ↓ 独立故事并行实现
    ├→ 智能体 1：STORY-001 后端
    ├→ 智能体 2：STORY-002 后端
    ├→ 智能体 3：STORY-003 前端
    └→ 智能体 4：集成测试
    ↓ 集成和验证
完成冲刺
```

**ECC 应用场景：**
- 多个独立 Bug 修复并行处理
- 多个不相关的功能模块并行开发
- 测试用例并行编写

**适用条件：**
- 故事之间无阻塞依赖
- 故事触及不同文件/组件
- 每个故事工作量实质性

---

## 协调策略

### 共享上下文文件

启动并行智能体前，将共享信息写入文件：

```
1. 写入共享上下文到 .claude/plans/parallel-context.md
2. 启动智能体，提示中包含：「读取 .claude/plans/parallel-context.md 获取上下文」
3. 每个智能体写入输出到 .claude/plans/parallel-output-{n}.md
4. 主上下文收集并合成所有输出
```

### 分阶段依赖管理

当任务存在部分依赖时，使用分阶段并行：

```
阶段 1（并行）：智能体 A, B, C（无依赖）
                    ↓
              等待所有完成
                    ↓
阶段 2（并行）：智能体 D（依赖 A）, E（依赖 B+C）
                    ↓
              等待所有完成
                    ↓
阶段 3（顺序）：主上下文中的最终合成
```

### 结果收集

```python
# 伪代码
agents = []
agents.append(launch_agent("任务 1", background=True))
agents.append(launch_agent("任务 2", background=True))
agents.append(launch_agent("任务 3", background=True))

# 继续其他工作...

# 准备好时收集结果
for agent in agents:
    result = get_agent_output(agent, block=True)
    process(result)
```

最佳实践：
- 先启动所有并行智能体，再等待任何结果
- 用 `block=False` 检查进度，`block=True` 等待完成
- 优雅处理部分失败

---

## ECC 预定义并行工作流

### 并行审查 (parallel-review)

同时进行多维度代码审查：

```
代码变更
    ├→ code-reviewer（代码质量）
    ├→ security-reviewer（安全性）
    └→ architect（架构合理性）
    ↓ 合成
统一审查报告
```

### 并行规划 (parallel-plan)

复杂功能的多角度规划：

```
功能需求
    ├→ planner（实施规划）
    ├→ architect（架构设计）
    └→ security-reviewer（安全分析）
    ↓ 合成
综合规划文档
```

### 混合功能开发 (hybrid-feature)

结合顺序和并行的完整功能开发流程：

```
阶段 1（顺序）：planner → 生成实施计划
                    ↓
阶段 2（并行）：tdd-guide + architect（并行编码和设计验证）
                    ↓
阶段 3（并行）：code-reviewer + security-reviewer（并行审查）
                    ↓
阶段 4（顺序）：合成最终报告
```

### 并行诊断 (parallel-diagnose)

复杂问题的多假设并行验证：

```
问题描述
    ├→ error-diagnostician（根因分析）
    ├→ build-error-resolver（构建层面排查）
    └→ security-reviewer（安全层面排查）
    ↓ 合成
诊断报告
```

---

## 子智能体提示词模板

每个子智能体的提示词必须自包含（子智能体看不到主对话）：

```markdown
## 任务：[具体任务名称]

## 上下文
[提供所有必要上下文]
- 项目：{{项目名称}}
- 阶段：{{当前阶段}}
- 相关文件：[列出需要读取的文件路径]

## 目标
[清晰、具体的目标描述]

## 约束
- [限制条件或要求]
- 输出格式：[指定期望的输出格式]

## 交付物
1. [具体交付物 1]
2. [具体交付物 2]

## 输出位置
将结果写入：[具体文件路径]
```

---

## Token 预算指南

每个子智能体约 200K tokens（Sonnet/Opus 4.6 支持 1M）：

| 活动 | Token 预算 | 占比 |
|------|-----------|------|
| 上下文加载 | ~20K | 10% |
| 研究/探索 | ~100K | 50% |
| 生成/写作 | ~50K | 25% |
| 验证 | ~30K | 15% |

节省 Token 的技巧：
- 共享上下文文件控制在 5-10K tokens
- 引用模板而非包含全文
- 用 `Explore`（Haiku）做快速查询，节省预算给生成任务
- 按需加载参考文档

---

## 反模式

**禁止：**
- 为琐碎任务（<1K tokens）启动智能体
- 将整个对话历史传给子智能体
- 创建深层嵌套的子智能体链
- 将有依赖关系的任务并行启动
- 一次启动超过 6 个智能体

**正确做法：**
- 每个子智能体的提示词自包含
- 通过文件共享上下文，而非传递对话
- 保持并行层级扁平（最多 2 层）
- 先识别依赖关系，再决定并行策略

---

## 决策矩阵：何时并行 vs 顺序

| 场景 | 推荐模式 | 原因 |
|------|----------|------|
| 代码审查 + 安全审查 | 并行 | 完全独立 |
| 规划 → 编码 | 顺序 | 编码依赖规划结果 |
| 规划 + 架构设计 | 并行 | 可独立进行，后续合成 |
| 编码 → 测试 | 顺序 | 测试依赖实现代码 |
| 多个 Bug 修复 | 并行 | 通常触及不同文件 |
| 构建修复 → 验证 | 顺序 | 验证依赖修复结果 |
| 多维度分析 | 并行 | 各维度独立 |
| 文档各章节 | 并行 | 章节逻辑独立 |

---

## 参考

- BMAD 并行子智能体架构：`claude-code-bmad-skills/docs/subagent-patterns.md`
- ECC 智能体编排规则：`rules/agents.md`
- ECC 编排命令：`commands/orchestrate.md`
- 标准化操作参考：`helpers.md#并行执行协调`
