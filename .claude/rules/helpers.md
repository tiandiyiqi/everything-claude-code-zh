# Helpers — 标准化操作参考中心

> 本文件是 Everything Claude Code 的指令解耦核心。
> 所有智能体、技能、命令和规则通过锚点引用本文件中的标准化操作，
> 而非各自重复定义相同内容。

---

## 领域一：标准工作流模板

### 规划工作流模板

```
1. 需求分析 → 理解功能请求，确定验收标准
2. 架构评审 → 分析现有代码库，确定受影响组件
3. 步骤拆解 → 创建详细步骤（文件路径、依赖关系、风险）
4. 实施顺序 → 按依赖关系排优先级，支持增量测试
```

### 代码审查工作流模板

```
1. 运行 git diff 查看最近更改
2. 按优先级审查：
   - 严重 (CRITICAL)：安全漏洞、硬编码凭据 → 必须修复
   - 高 (HIGH)：代码质量问题（大函数、缺失错误处理） → 应该修复
   - 中 (MEDIUM)：性能、最佳实践 → 考虑改进
3. 给出合并决策：
   - ✅ 立即合并：无 CRITICAL/HIGH 问题
   - ⚠️ 修改后合并：存在 HIGH 但可快速修复
   - ❌ 需要重构：存在 CRITICAL 安全问题或架构缺陷
4. 指出代码中做得好的地方（正面反馈）
```

### 构建错误修复工作流模板

```
1. 收集所有错误
   - 运行完整类型检查：npx tsc --noEmit --pretty
   - 按类型分类：类型推断、缺失定义、导入/导出、配置、依赖
   - 按影响排序：阻塞构建 > 类型错误 > 警告

2. 逐个修复（最小差异策略）
   - 理解错误信息，检查文件和行号
   - 寻找最小修复方案（添加类型注解、修复导入、添加空值检查）
   - 每次修复后重新编译验证
   - 跟踪进度：已修复 X/Y 个错误

3. 禁止事项
   - ❌ 重构不相关代码
   - ❌ 更改架构
   - ❌ 添加新功能
   - ❌ 优化性能或改善代码风格
```

---

## 领域二：报告格式模板

### 验证报告模板

```
VERIFICATION REPORT
==================

Build:     [PASS/FAIL]
Types:     [PASS/FAIL] (X errors)
Lint:      [PASS/FAIL] (X warnings)
Tests:     [PASS/FAIL] (X/Y passed, Z% coverage)
Security:  [PASS/FAIL] (X issues)
Diff:      [X files changed]

Overall:   [READY/NOT READY] for PR

Issues to Fix:
1. ...
2. ...
```

### 构建错误修复报告模板

```markdown
# 构建错误修复报告

**构建目标：** Next.js 生产环境 / TypeScript 检查 / ESLint
**初始错误数：** X
**已修复错误数：** Y
**构建状态：** ✅ 通过 / ❌ 失败

## 已修复的错误

### 1. [错误类别]
**位置：** `src/path/file.ts:行号`
**错误信息：** [原始错误]
**根本原因：** [原因说明]
**修复：** 修改行数 N，影响：无/[说明]

## 验证步骤
1. ✅ TypeScript 检查通过
2. ✅ 构建成功
3. ✅ 未引入新错误
```

### 安全审查报告模板

```markdown
# 安全审查报告

**文件/组件：** [path/to/file.ts]
**审查人：** security-reviewer 智能体

## 摘要
- **致命 (Critical):** X
- **高危 (High):** Y
- **中危 (Medium):** Z
- **风险等级：** 🔴 高 / 🟡 中 / 🟢 低

## [严重程度] 问题
**类别：** [SQL 注入 / XSS / 身份验证 / 等]
**位置：** `file.ts:行号`
**问题描述：** [漏洞说明]
**影响：** [被利用后果]
**修复建议：** [安全实现方案]
**参考：** OWASP / CWE 编号
```

### 诊断报告模板

```markdown
# 错误诊断报告

## 问题概览
- **问题描述**：[现象]
- **发生时间**：[时间和频率]
- **影响范围**：[用户和功能]
- **紧急程度**：[P0/P1/P2/P3]

## 根因分析
### 时间线
[时间点1] → [时间点2] → [问题爆发]

### 原因链
1. **直接原因**：[直接因素]
2. **间接原因**：[深层因素]
3. **根本原因**：[最深层原因]

## 解决方案
- **临时措施**：[快速恢复方案]
- **根因修复**：[彻底修复方案]
- **预防措施**：[监控 + 流程 + 测试]
```

### 代码审查输出格式

```
[CRITICAL/HIGH/MEDIUM] 问题标题
文件: src/path/file.ts:行号
问题: 问题描述
修复: 修复建议

代码示例（错误 vs 正确）
```

---

## 领域三：检查清单模板

### 安全检查清单

提交代码前必须确认：

- [ ] 无硬编码凭据（API 密钥、密码、令牌）
- [ ] 所有用户输入已验证和净化
- [ ] SQL 查询使用参数化方式（预防注入）
- [ ] HTML 输出已转义（预防 XSS）
- [ ] 已启用 CSRF 保护
- [ ] 身份验证/授权已验证
- [ ] 所有端点已设置速率限制
- [ ] 错误消息不泄露敏感数据
- [ ] 敏感数据已加密或脱敏
- [ ] 依赖项已更新，无已知漏洞

### 代码质量自检清单

- [ ] 代码易读且命名良好
- [ ] 函数体量小（<50 行）
- [ ] 文件内容聚焦（<800 行）
- [ ] 无深度嵌套（>4 层）
- [ ] 具备完善的错误处理
- [ ] 不存在 console.log 语句
- [ ] 不存在硬编码数值
- [ ] 不存在修改原对象操作（已采用不可变模式）

### 测试质量检查清单

- [ ] 所有公共函数都有单元测试
- [ ] 所有 API 接口都有集成测试
- [ ] 关键用户流程有 E2E 测试
- [ ] 覆盖了边界情况（null、空值、无效输入）
- [ ] 测试了错误路径（不只是正常流程）
- [ ] 对外部依赖使用了 Mock
- [ ] 测试是独立的（无共享状态）
- [ ] 测试名称描述了被测内容
- [ ] 断言明确且有意义
- [ ] 覆盖率达到 80%+

### 结构化代码审查清单

**安全维度：**
- [ ] 无硬编码凭据
- [ ] 所有用户输入已验证和净化
- [ ] SQL 查询使用参数化方式
- [ ] 敏感数据已加密或脱敏
- [ ] 权限检查覆盖所有端点
- [ ] 错误信息不泄露内部实现细节

**性能维度：**
- [ ] 无 N+1 查询问题
- [ ] 热点数据有缓存策略
- [ ] 大数据集有分页处理
- [ ] 异步操作正确使用 async/await
- [ ] 资源（连接、文件句柄）及时释放
- [ ] 无不必要的重复计算或渲染

**代码质量维度：**
- [ ] 函数职责单一，体量小（<50 行）
- [ ] 文件内容聚焦（<800 行）
- [ ] 命名清晰一致，无歧义
- [ ] 错误处理完善，无静默失败
- [ ] 无重复代码（DRY 原则）
- [ ] 使用不可变模式，无直接修改原对象

---

## 领域四：错误处理协议

### 三次错误协议

当同一个错误反复出现时，遵循递进式修复策略：

```
尝试 1：诊断并修复
  → 仔细阅读错误信息
  → 识别根本原因
  → 应用针对性修复
  → 记录到 task_plan.md 错误表（如果 file-memory 激活）

尝试 2：替代方案
  → 同样错误？尝试不同方法
  → 不同工具？不同库？不同配置？
  → 永远不要重复完全相同的失败操作
  → 更新错误表的尝试次数

尝试 3：更广泛的重新思考
  → 质疑假设——错误的根因可能不是你想的那样
  → 搜索解决方案（Stack Overflow、GitHub Issues）
  → 考虑是否需要更新整体方案

3 次失败后：升级给用户
  → 解释尝试了什么（3 种不同方法）
  → 分享具体错误信息
  → 请求指导或额外上下文
```

### 安全应急响应协议

发现致命安全漏洞时：

```
1. 立即停止当前工作
2. 记录 — 创建详细报告
3. 通知 — 立即向项目所有者发出警报
4. 建议修复 — 提供安全的代码示例
5. 测试修复 — 验证修复方案有效
6. 核实影响 — 检查漏洞是否已被利用
7. 轮换密钥 — 若凭据已泄露
```

### 问题优先级分类

```
P0-紧急：系统不可用、数据丢失、安全漏洞 → 立即响应
P1-高：  核心功能异常、性能严重下降 → 尽快处理
P2-中：  部分功能异常、用户体验受影响 → 排期修复
P3-低：  偶发问题、轻微体验影响 → 有空处理
```

---

## 领域五：File-Memory 集成

### 三文件模式

| 文件 | 用途 | 更新时机 |
|------|------|----------|
| `task_plan.md` | 阶段跟踪、进度、决策、错误表 | 每个阶段完成后 |
| `findings.md` | 研究发现、技术决策、知识存储 | 任何发现后立即更新 |
| `progress.md` | 会话日志、测试结果、5 问题重启检查 | 整个会话过程中 |

文件位置：`.claude/plans/` 目录下。

### 六条核心规则

1. **先创建计划** — 永远不要在没有 `task_plan.md` 的情况下开始复杂任务
2. **2 操作规则** — 每进行 2 次查看/浏览/搜索操作后，立即将关键发现保存到 `findings.md`
3. **决策前读取** — 在做出重大决策前，读取 `task_plan.md`（利用注意力操纵原理）
4. **行动后更新** — 完成阶段后更新状态、记录错误、记录文件变更
5. **记录所有错误** — 每个错误都记录在错误表中：`| 错误描述 | 尝试次数 | 解决方案 |`
6. **三次错误协议** — 参见 [三次错误协议](#三次错误协议)

### 读写决策矩阵

| 情况 | 操作 | 原因 |
|------|------|------|
| 刚写入文件 | 不读取 | 内容仍在上下文中 |
| 查看图片/PDF | 立即写入发现 | 多模态→文本，防止丢失 |
| 浏览器返回数据 | 写入文件 | 截图不持久 |
| 开始新阶段 | 读取计划/发现 | 上下文可能过时 |
| 发生错误 | 读取相关文件 | 需要当前状态来修复 |
| 间隔后恢复 | 读取所有规划文件 | 恢复状态 |

### 五问题重启测试

会话恢复时，如果能回答这 5 个问题，说明上下文管理良好：

| 问题 | 答案来源 |
|------|----------|
| 我在哪里？ | `task_plan.md` 中的当前阶段 |
| 我要去哪里？ | 剩余阶段 |
| 目标是什么？ | 计划中的目标陈述 |
| 我学到了什么？ | `findings.md` |
| 我做了什么？ | `progress.md` |

### Planner 智能体协调

当 `.claude/plans/task_plan.md` 存在时：
1. 将实施方案的阶段列表写入 `task_plan.md` 的"阶段列表"部分
2. 将关键技术决策写入 `task_plan.md` 的"决策记录"表
3. 将识别的风险记录到 `findings.md`

---

## 领域六：通用验证六阶段

### 阶段 1：构建验证

```bash
npm run build 2>&1 | tail -20
# 或 pnpm build 2>&1 | tail -20
```

如果构建失败，停止并修复后再继续。

### 阶段 2：类型检查

```bash
# TypeScript
npx tsc --noEmit 2>&1 | head -30
# Python
pyright . 2>&1 | head -30
```

### 阶段 3：Lint 检查

```bash
# JavaScript/TypeScript
npm run lint 2>&1 | head -30
# Python
ruff check . 2>&1 | head -30
```

### 阶段 4：测试套件

```bash
npm run test -- --coverage 2>&1 | tail -50
# 目标：最低 80% 覆盖率
```

### 阶段 5：安全扫描

```bash
# 检查密钥
grep -rn "sk-" --include="*.ts" --include="*.js" . 2>/dev/null | head -10
grep -rn "api_key" --include="*.ts" --include="*.js" . 2>/dev/null | head -10
# 检查 console.log
grep -rn "console.log" --include="*.ts" --include="*.tsx" src/ 2>/dev/null | head -10
```

### 阶段 6：差异审查

```bash
git diff --stat
git diff HEAD~1 --name-only
```

审查每个变更文件，确认无意间变更、缺失错误处理、潜在边缘情况。

---

## 领域七：TDD 工作流

### 通用TDD红绿重构循环

```
步骤 1：先写测试（红 / RED）
  → 始终从一个失败的测试开始
  → 覆盖正常流程、边界情况、错误场景

步骤 2：运行测试（验证失败 / FAILS）
  → 测试应当失败——因为功能尚未实现

步骤 3：编写最简实现（绿 / GREEN）
  → 只编写刚好能通过测试的代码

步骤 4：运行测试（验证通过 / PASSES）
  → 所有测试应当通过

步骤 5：重构（改进 / IMPROVE）
  → 消除重复、优化命名、提升性能、增强可读性

步骤 6：验证覆盖率
  → 运行 test:coverage，验证 80%+
  → 核心代码（财务计算、认证逻辑、安全代码）要求 100%
```

### 测试金字塔比例

- **70% 单元测试**：快速、独立、大量覆盖函数和方法
- **20% 集成测试**：验证组件间协作、API 接口、数据库操作
- **10% E2E 测试**：覆盖核心用户场景和关键业务流程

### 测试用例设计方法

- **简单输入验证** → 等价类划分法
- **多条件组合逻辑** → 因果图法
- **用户流程测试** → 场景分析法
- **有状态系统** → 状态迁移法
- **复杂功能** → 组合使用多种方法

### 必须测试的边界情况

1. **Null/Undefined**：输入为 null 怎么办？
2. **空值**：数组/字符串为空怎么办？
3. **无效类型**：传入错误类型怎么办？
4. **边界值**：最小/最大值
5. **错误**：网络失败、数据库错误
6. **竞态条件**：并发操作
7. **大数据**：10k+ 条数据时的性能
8. **特殊字符**：Unicode、表情符号、SQL 字符

### TDD 最佳实践

**建议做法：**
- ✅ 先编写测试，在进行任何实现之前
- ✅ 运行测试并验证它们失败后再写实现
- ✅ 编写最小化代码以使测试通过
- ✅ 仅在测试通过后才进行重构
- ✅ 涵盖边界情况和错误场景
- ✅ 目标 80%+ 覆盖率（核心代码 100%）

**避免做法：**
- ❌ 在测试之前编写实现
- ❌ 每次更改后跳过运行测试
- ❌ 一次性编写过多代码
- ❌ 忽略失败的测试
- ❌ 测试实现细节（应测试行为）
- ❌ Mock 一切（更推荐集成测试）

---

## 领域八：安全审查流程

### OWASP Top 10 检查

```
1. 注入 (SQL, NoSQL, Command)
   → 查询是否参数化？用户输入是否经过清洗？

2. 失效的身份验证
   → 密码是否哈希处理？JWT 是否正确验证？会话是否安全？

3. 敏感数据泄露
   → 是否强制 HTTPS？密钥是否在环境变量中？PII 是否加密？

4. XML 外部实体 (XXE)
   → XML 解析器配置是否安全？

5. 失效的访问控制
   → 每个路由是否检查授权？CORS 配置是否正确？

6. 安全配置错误
   → 默认凭据是否已更改？安全标头是否设置？

7. 跨站脚本 (XSS)
   → 输出是否转义/清洗？是否设置 CSP？

8. 不安全的反序列化
   → 用户输入反序列化是否安全？

9. 使用含已知漏洞的组件
   → 依赖项是否已更新？npm audit 是否清空？

10. 日志记录和监控不足
    → 安全事件是否记录？是否配置告警？
```

### 安全审查触发条件

**必须审查：**
- 添加新 API 端点
- 更改身份验证/授权代码
- 添加用户输入处理逻辑
- 修改数据库查询
- 添加文件上传功能
- 更改支付/金融代码
- 添加外部 API 集成
- 更新依赖项

### 凭据管理规范

```typescript
// 严禁：硬编码凭据
const apiKey = "sk-proj-xxxxx"

// 推荐：环境变量
const apiKey = process.env.OPENAI_API_KEY
if (!apiKey) {
  throw new Error('OPENAI_API_KEY not configured')
}
```

---

## 领域九：并行执行协调

### 并行执行核心原则

**能并行的，绝不串行。** 通过 `Task` 工具的 `run_in_background=true` 实现并行子智能体。

### 四大并行模式

| 模式 | 适用场景 | 智能体数 |
|------|----------|---------|
| 扇形研究 | 多个独立研究领域 | 3-6 |
| 并行章节生成 | 大型文档各章节独立生成 | 3-4 |
| 组件并行设计 | 系统组件独立设计 | 4-6 |
| 故事并行实现 | 冲刺中独立故事并行开发 | 3-5 |

详细模式说明参见 `skills/parallel-patterns/SKILL.md`。

### 子智能体类型选择

| 类型 | 模型 | 适用场景 |
|------|------|----------|
| general-purpose | 继承父级 | 研究、实现、分析 |
| Explore | Haiku | 快速代码库探索（只读） |
| Plan | 继承父级 | 架构规划（只读） |
| Bash | 继承父级 | 隔离的终端命令 |

### 共享上下文协调

```
1. 写入共享上下文到 .claude/plans/parallel-context.md
2. 启动智能体，提示中包含文件路径
3. 每个智能体写入输出到 .claude/plans/parallel-output-{n}.md
4. 主上下文收集并合成所有输出
```

### 并行 vs 顺序决策矩阵

| 场景 | 推荐 | 原因 |
|------|------|------|
| 代码审查 + 安全审查 | 并行 | 完全独立 |
| 规划 → 编码 | 顺序 | 编码依赖规划 |
| 规划 + 架构设计 | 并行 | 可独立进行 |
| 编码 → 测试 | 顺序 | 测试依赖代码 |
| 多维度分析 | 并行 | 各维度独立 |
| 构建修复 → 验证 | 顺序 | 验证依赖修复 |

### 并行执行检查清单

- [ ] 确认任务之间无依赖关系
- [ ] 共享上下文已写入文件
- [ ] 每个智能体有清晰的输出位置
- [ ] 子智能体提示词自包含
- [ ] 已规划结果合成方法
- [ ] 智能体数量不超过 6 个

### 反模式

- ❌ 为琐碎任务（<1K tokens）启动智能体
- ❌ 将整个对话历史传给子智能体
- ❌ 创建深层嵌套的子智能体链
- ❌ 将有依赖关系的任务并行启动
- ❌ 一次启动超过 6 个智能体

---

## 领域十：Superpowers 工作流

### Git Worktree 管理规范

#### 目录选择优先级

```
1. 检查现有目录
   - .worktrees/ （首选，隐藏目录）
   - worktrees/ （备选）
   - 如果两者都存在，使用 .worktrees/

2. 检查 CLAUDE.md 配置
   - 搜索 worktree 目录偏好设置
   - 如果指定，直接使用

3. 询问用户
   - 项目本地：.worktrees/
   - 全局位置：~/.config/superpowers/worktrees/<project-name>/
```

#### 安全验证流程

**项目本地目录（必须验证）：**

```bash
# 检查目录是否被 git 忽略
git check-ignore -q .worktrees 2>/dev/null

# 如果未被忽略
echo ".worktrees/" >> .gitignore
git add .gitignore
git commit -m "chore: ignore worktrees directory"
```

**全局目录：** 无需验证（在项目外）

#### 创建工作树标准流程

```bash
# 1. 检测项目名称
project=$(basename "$(git rev-parse --show-toplevel)")

# 2. 创建工作树
git worktree add "$path" -b "$BRANCH_NAME"
cd "$path"

# 3. 自动运行项目设置
if [ -f package.json ]; then npm install; fi
if [ -f Cargo.toml ]; then cargo build; fi
if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
if [ -f pyproject.toml ]; then poetry install; fi
if [ -f go.mod ]; then go mod download; fi

# 4. 验证测试基线
npm test / cargo test / pytest / go test ./...

# 5. 报告状态
echo "工作树已就绪，位于 $path"
echo "测试通过（N 个测试，0 个失败）"
```

### 完成分支工作流

#### 标准流程

```
步骤 1：验证测试
  → 运行项目测试套件
  → 如果失败，停止并报告
  → 如果通过，继续

步骤 2：确定基础分支
  → git merge-base HEAD main
  → 或询问用户确认

步骤 3：呈现 4 个选项
  1. 本地合并回基础分支
  2. 推送并创建 Pull Request
  3. 保持分支原样
  4. 丢弃此工作

步骤 4：执行选择
  → 根据用户选择执行操作
  → 选项 4 需要输入 'discard' 确认

步骤 5：清理工作树
  → 选项 1、2、4：清理工作树
  → 选项 3：保留工作树
```

#### 选项执行矩阵

| 选项 | 合并 | 推送 | 保留工作树 | 清理分支 |
|------|------|------|-----------|---------|
| 1. 本地合并 | ✓ | - | - | ✓ |
| 2. 创建 PR | - | ✓ | ✓ | - |
| 3. 保持原样 | - | - | ✓ | - |
| 4. 丢弃 | - | - | - | ✓（强制） |

### 细粒度任务拆解模板

#### 任务粒度标准

**每个步骤 = 一个动作（2-5 分钟）：**

```
步骤 1：编写失败的测试（2-3 分钟）
步骤 2：运行测试验证失败（30 秒）
步骤 3：编写最小实现（2-4 分钟）
步骤 4：运行测试验证通过（30 秒）
步骤 5：提交（1 分钟）
```

#### 计划文档结构

```markdown
# [功能名称] 实施计划

> **给 Claude：** 必需的子技能：使用 superpowers:executing-plans

**目标：** [一句话描述]
**架构：** [2-3 句话]
**技术栈：** [关键技术]

---

### 任务 N：[组件名称]

**文件：**
- 创建：`exact/path/to/file.py`
- 修改：`exact/path/to/existing.py:123-145`
- 测试：`tests/exact/path/to/test.py`

**步骤 1：编写失败的测试**
[完整代码]

**步骤 2：运行测试验证失败**
运行：`pytest tests/path/test.py::test_name -v`
预期：FAIL

**步骤 3：编写最小实现**
[完整代码]

**步骤 4：运行测试验证通过**
运行：`pytest tests/path/test.py::test_name -v`
预期：PASS

**步骤 5：提交**
```bash
git add ...
git commit -m "feat: ..."
```
```

#### 任务拆解检查清单

- [ ] 每个任务 2-5 分钟可完成
- [ ] 包含完整文件路径
- [ ] 包含完整代码（不是"添加验证"）
- [ ] 包含精确命令和预期输出
- [ ] 遵循 TDD 红-绿-重构循环
- [ ] 每个任务独立可测试
- [ ] 频繁提交（每个任务一次）

### Superpowers 工作流集成

#### 完整工作流

```
1. 头脑风暴（Brainstorming）
   ↓
2. 创建工作树（superpowers-git-worktree）
   ↓
3. 编写计划（superpowers-task-planning）
   ↓
4. 执行任务（subagent-driven-development）
   ↓
5. 完成分支（superpowers-finishing-branch）
```

#### 与现有工作流的关系

| Everything Claude Code | Superpowers | 关系 |
|------------------------|-------------|------|
| /plan | /superpowers-plan | 互补（高层 vs 细粒度） |
| /workflow | superpowers 完整流程 | 可组合使用 |
| /tdd | 强制 TDD 步骤 | 增强版 |
| planner agent | superpowers-task-planning | 细粒度版本 |

---

## 领域十一：进度跟踪模板

### 项目进度报告模板

```markdown
## 项目进度报告

### 总体状态
- 总任务数：[N]
- 已完成：[X] ([百分比]%)
- 进行中：[Y]
- 待办：[Z]
- 阻塞：[W]

### 已完成任务
- ✅ 任务 1：[描述]
  完成时间：[时间]
  审查状态：[通过/待审查]

- ✅ 任务 2：[描述]
  完成时间：[时间]
  审查状态：[通过/待审查]

### 进行中任务
- 🔄 任务 3：[描述]
  负责人：[智能体/人员]
  状态：[具体进度]
  预计完成：[估计]

### 待办任务
- ⏳ 任务 4：[描述]
  依赖：[依赖任务]
  优先级：[高/中/低]

- ⏳ 任务 5：[描述]
  依赖：[无]
  优先级：[高/中/低]
  建议：[可以立即开始]

### 阻塞任务
- 🚫 任务 6：[描述]
  阻塞原因：[具体原因]
  解决方案：[建议]

### 问题和风险
- ⚠️ [问题描述]
  影响：[影响范围]
  建议：[如何解决]

### 下一步行动
1. [建议的下一个任务]
2. [需要解决的阻塞]
3. [需要澄清的问题]

### 里程碑进度
- [里程碑 1]：[X/Y 任务完成] ([百分比]%)
- [里程碑 2]：[X/Y 任务完成] ([百分比]%)
```

### 任务状态定义

| 状态 | 图标 | 含义 | 何时使用 |
|------|------|------|----------|
| 待办 (Pending) | ⏳ | 尚未开始 | 任务已创建但未分配或未开始 |
| 进行中 (In Progress) | 🔄 | 正在实现 | 任务已分配且正在执行 |
| 审查中 (In Review) | 👀 | 等待审查 | 代码已完成，等待审查 |
| 已完成 (Completed) | ✅ | 已验证完成 | 审查通过，任务完成 |
| 阻塞 (Blocked) | 🚫 | 被其他任务阻塞 | 依赖未满足或遇到技术问题 |

### 任务跟踪表模板

```markdown
| ID | 任务 | 状态 | 负责人 | 依赖 | 开始时间 | 完成时间 | 备注 |
|----|------|------|--------|------|----------|----------|------|
| 1  | [任务描述] | ✅ | [名称] | - | [时间] | [时间] | [备注] |
| 2  | [任务描述] | 🔄 | [名称] | 1 | [时间] | - | [备注] |
| 3  | [任务描述] | ⏳ | - | 2 | - | - | [备注] |
| 4  | [任务描述] | 🚫 | [名称] | 1 | [时间] | - | 阻塞原因 |
```

### 依赖关系图模板

```
任务 1 (✅)
  ├─→ 任务 2 (🔄)
  │    ├─→ 任务 5 (⏳)
  │    └─→ 任务 6 (⏳)
  └─→ 任务 3 (🚫) [阻塞：等待外部 API]
       └─→ 任务 7 (⏳)

任务 4 (✅)
  └─→ 任务 8 (🔄)
```

### 关键指标跟踪

```markdown
### 进度指标
- **完成率**：[X/Y] ([百分比]%)
- **速度**：[N] 任务/天
- **阻塞率**：[X/Y] ([百分比]%)
- **审查通过率**：[X/Y] ([百分比]%)

### 质量指标
- **返工率**：[X/Y] ([百分比]%)
- **审查拒绝率**：[X/Y] ([百分比]%)
- **Bug 率**：[N] 个 Bug

### 效率指标
- **并行度**：[N] 个任务同时进行
- **平均等待时间**：[N] 小时
- **平均审查时间**：[N] 小时
```

### 问题跟踪表模板

```markdown
| ID | 问题 | 类型 | 优先级 | 状态 | 负责人 | 创建时间 | 解决时间 |
|----|------|------|--------|------|--------|----------|----------|
| 1  | [问题描述] | 技术 | P0 | 已解决 | [名称] | [时间] | [时间] |
| 2  | [问题描述] | 需求 | P1 | 进行中 | [名称] | [时间] | - |
| 3  | [问题描述] | 阻塞 | P0 | 待处理 | - | [时间] | - |
```

### 风险识别模板

```markdown
### 识别的风险

#### 🔴 高风险
- **风险描述**：[具体风险]
  - **影响**：[影响范围和严重程度]
  - **概率**：[高/中/低]
  - **缓解措施**：[如何降低风险]
  - **应急计划**：[风险发生时的应对]

#### 🟡 中风险
- **风险描述**：[具体风险]
  - **影响**：[影响范围]
  - **概率**：[高/中/低]
  - **缓解措施**：[预防措施]

#### 🟢 低风险
- **风险描述**：[具体风险]
  - **影响**：[轻微影响]
  - **监控措施**：[如何监控]
```

### 里程碑跟踪模板

```markdown
### 里程碑跟踪

#### 里程碑 1：[名称] - [目标日期]
**状态**：[进行中/已完成/延迟]
**完成度**：[X/Y 任务] ([百分比]%)

**包含任务**：
- ✅ 任务 1
- ✅ 任务 2
- 🔄 任务 3
- ⏳ 任务 4

**关键成果**：
- [成果 1]
- [成果 2]

**风险**：
- [风险描述]

#### 里程碑 2：[名称] - [目标日期]
**状态**：[未开始/进行中]
**完成度**：[X/Y 任务] ([百分比]%)

**依赖**：里程碑 1
```

### 每日站会报告模板

```markdown
## 每日站会 - [日期]

### [团队成员/智能体名称]

**昨天完成**：
- ✅ [任务描述]
- ✅ [任务描述]

**今天计划**：
- 🔄 [任务描述]
- ⏳ [任务描述]

**遇到的阻塞**：
- 🚫 [阻塞描述]
  - 需要：[需要的帮助]

**备注**：
- [其他信息]
```

### 周报模板

```markdown
## 周报 - [周数] ([开始日期] - [结束日期])

### 本周概览
- **完成任务**：[N] 个
- **进行中任务**：[N] 个
- **新增任务**：[N] 个
- **解决的阻塞**：[N] 个

### 主要成就
1. [成就描述]
2. [成就描述]
3. [成就描述]

### 完成的任务
- ✅ [任务 1]
- ✅ [任务 2]
- ✅ [任务 3]

### 进行中的任务
- 🔄 [任务 1] - [进度百分比]%
- 🔄 [任务 2] - [进度百分比]%

### 遇到的问题
- ⚠️ [问题描述]
  - 解决方案：[如何解决]
- ⚠️ [问题描述]
  - 状态：[待解决/已解决]

### 下周计划
1. [计划任务 1]
2. [计划任务 2]
3. [计划任务 3]

### 需要的支持
- [需要的帮助或资源]
```

### 进度跟踪最佳实践

**及时更新**：
- 任务状态变化时立即更新
- 发现问题时立即记录
- 每日更新进度报告
- 每周生成周报

**保持准确**：
- 验证任务真正完成（不只是代码写完）
- 确认审查结果
- 核实阻塞原因
- 准确报告状态

**保持主动**：
- 提前识别潜在问题
- 主动建议优化措施
- 及时沟通风险
- 协助解决阻塞

**保持清晰**：
- 使用统一的状态定义
- 提供具体的数据
- 给出可操作的建议
- 保持报告简洁明了
